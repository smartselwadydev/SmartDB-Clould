// functions/api/proxy.jsexport async function onRequest(context) {  const { request } = context;    // Handle CORS preflight requests  if (request.method === 'OPTIONS') {    return handleOptions(request);  }  try {    // Get the target URL from the query parameters    const url = new URL(request.url);    const targetUrl = url.searchParams.get('url');        // Create response object with URL info    const responseData = {      timestamp: new Date().toISOString(),      request: {        url: request.url,        method: request.method,        targetUrl: targetUrl || null,        headers: Object.fromEntries(request.headers),      },      proxy: {        status: 'processing',        message: 'URL received successfully'      }    };    // Validate URL presence    if (!targetUrl) {      responseData.proxy.status = 'error';      responseData.proxy.message = 'Missing "url" parameter';            return new Response(JSON.stringify(responseData, null, 2), {        status: 400,        headers: {          'Content-Type': 'application/json',          ...corsHeaders(request)        }      });    }    // Validate URL format    try {      new URL(targetUrl);      responseData.proxy.urlValidation = 'valid';    } catch {      responseData.proxy.status = 'error';      responseData.proxy.message = 'Invalid URL provided';      responseData.proxy.urlValidation = 'invalid';            return new Response(JSON.stringify(responseData, null, 2), {        status: 400,        headers: {          'Content-Type': 'application/json',          ...corsHeaders(request)        }      });    }    // Add parsed URL information    const parsedUrl = new URL(targetUrl);    responseData.request.parsedUrl = {      protocol: parsedUrl.protocol,      hostname: parsedUrl.hostname,      port: parsedUrl.port,      pathname: parsedUrl.pathname,      search: parsedUrl.search,      hash: parsedUrl.hash,      origin: parsedUrl.origin    };    // Prepare the request to forward    const proxyRequest = new Request(targetUrl, {      method: request.method,      headers: filterHeaders(request.headers),      body: request.method !== 'GET' && request.method !== 'HEAD' ? request.body : undefined,    });    // Fetch the target URL    const fetchStartTime = Date.now();    const response = await fetch(proxyRequest);    const fetchEndTime = Date.now();    // Add proxy metadata    responseData.proxy = {      ...responseData.proxy,      status: 'success',      message: 'Request forwarded successfully',      fetchTimeMs: fetchEndTime - fetchStartTime,      targetResponse: {        status: response.status,        statusText: response.statusText,        ok: response.ok,        redirected: response.redirected,        type: response.type      }    };    // For JSON responses, we can include the body in our response    const contentType = response.headers.get('content-type');    if (contentType && contentType.includes('application/json')) {      const responseBody = await response.json();      responseData.proxy.targetResponse.body = responseBody;            // Return combined JSON response      return new Response(JSON.stringify(responseData, null, 2), {        status: 200,        headers: {          'Content-Type': 'application/json',          ...corsHeaders(request)        }      });    }    // For non-JSON responses, return the original response with our metadata in headers    const proxyResponse = new Response(response.body, {      status: response.status,      statusText: response.statusText,      headers: filterResponseHeaders(response.headers),    });    // Add CORS headers and proxy metadata headers    addCorsHeaders(proxyResponse.headers, request);    proxyResponse.headers.set('X-Proxy-Url', targetUrl);    proxyResponse.headers.set('X-Proxy-Timestamp', responseData.timestamp);    proxyResponse.headers.set('X-Proxy-Fetch-Time', responseData.proxy.fetchTimeMs);    return proxyResponse;  } catch (error) {    const errorResponse = {      timestamp: new Date().toISOString(),      request: {        url: request.url,        method: request.method,        headers: Object.fromEntries(request.headers),      },      proxy: {        status: 'error',        message: `Proxy error: ${error.message}`,        errorType: error.name      }    };    return new Response(JSON.stringify(errorResponse, null, 2), {      status: 500,      headers: {        'Content-Type': 'application/json',        ...corsHeaders(request)      }    });  }}// Handle OPTIONS preflight requestsfunction handleOptions(request) {  return new Response(null, {    status: 204,    headers: corsHeaders(request)  });}// Filter headers to forward (remove sensitive/unsafe headers)function filterHeaders(headers) {  const forbiddenHeaders = [    'cookie',    'origin',    'referer',    'user-agent',    'accept-encoding',    'content-length',  ];  const filteredHeaders = new Headers();    for (const [key, value] of headers.entries()) {    if (!forbiddenHeaders.includes(key.toLowerCase())) {      filteredHeaders.set(key, value);    }  }  // Set a custom user agent  filteredHeaders.set('User-Agent', 'Cloudflare-CORS-Proxy/1.0');    return filteredHeaders;}// Filter response headersfunction filterResponseHeaders(headers) {  const forbiddenResponseHeaders = [    'set-cookie',    'content-security-policy',    'content-security-policy-report-only',  ];  const filteredHeaders = new Headers();    for (const [key, value] of headers.entries()) {    if (!forbiddenResponseHeaders.includes(key.toLowerCase())) {      filteredHeaders.set(key, value);    }  }    return filteredHeaders;}// Generate CORS headersfunction corsHeaders(request) {  const origin = request.headers.get('Origin') || '*';    return {    'Access-Control-Allow-Origin': origin,    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS',    'Access-Control-Allow-Headers': '*',    'Access-Control-Allow-Credentials': 'true',    'Access-Control-Max-Age': '86400',    'Vary': 'Origin',  };}// Add CORS headers to responsefunction addCorsHeaders(headers, request) {  const cors = corsHeaders(request);    for (const [key, value] of Object.entries(cors)) {    headers.set(key, value);  }}