// functions/api/proxy.jsexport async function onRequest(context) {  const { request } = context;    // Handle CORS preflight requests  if (request.method === 'OPTIONS') {    return handleOptions(request);  }  try {    // Get the target URL and printSource flag from the query parameters    const url = new URL(request.url);    const targetUrl = url.searchParams.get('url');    const printSource = url.searchParams.get('printSource') === 'true';        if (!targetUrl) {      return new Response('Missing "url" parameter', { status: 400 });    }    // Validate the URL    try {      new URL(targetUrl);    } catch {      return new Response('Invalid URL provided', { status: 400 });    }    // Prepare the request to forward    const proxyRequest = new Request(targetUrl, {      method: request.method,      headers: filterHeaders(request.headers),      body: request.method !== 'GET' && request.method !== 'HEAD' ? request.body : undefined,    });    // Fetch the target URL    const response = await fetch(proxyRequest);    // If printSource is true, return the HTML source code    if (printSource) {      const text = await response.text();            // Create a response with the HTML source code      const sourceResponse = new Response(text, {        status: 200,        headers: {          'Content-Type': 'text/plain;charset=UTF-8',        },      });            // Add CORS headers      addCorsHeaders(sourceResponse.headers, request);            return sourceResponse;    }    // Otherwise, proxy the response as normal    const proxyResponse = new Response(response.body, {      status: response.status,      statusText: response.statusText,      headers: filterResponseHeaders(response.headers),    });    // Add CORS headers    addCorsHeaders(proxyResponse.headers, request);    return proxyResponse;  } catch (error) {    return new Response(`Proxy error: ${error.message}`, {       status: 500,      headers: corsHeaders(request)    });  }}// Handle OPTIONS preflight requestsfunction handleOptions(request) {  return new Response(null, {    status: 204,    headers: corsHeaders(request)  });}// Filter headers to forward (remove sensitive/unsafe headers)function filterHeaders(headers) {  const forbiddenHeaders = [    'cookie',    'origin',    'referer',    'user-agent',    'accept-encoding',    'content-length',  ];  const filteredHeaders = new Headers();    for (const [key, value] of headers.entries()) {    if (!forbiddenHeaders.includes(key.toLowerCase())) {      filteredHeaders.set(key, value);    }  }  // Set a custom user agent  filteredHeaders.set('User-Agent', 'Cloudflare-CORS-Proxy/1.0');    return filteredHeaders;}// Filter response headersfunction filterResponseHeaders(headers) {  const forbiddenResponseHeaders = [    'set-cookie',    'content-security-policy',    'content-security-policy-report-only',  ];  const filteredHeaders = new Headers();    for (const [key, value] of headers.entries()) {    if (!forbiddenResponseHeaders.includes(key.toLowerCase())) {      filteredHeaders.set(key, value);    }  }    return filteredHeaders;}// Generate CORS headersfunction corsHeaders(request) {  const origin = request.headers.get('Origin') || '*';    return {    'Access-Control-Allow-Origin': origin,    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS',    'Access-Control-Allow-Headers': '*',    'Access-Control-Allow-Credentials': 'true',    'Access-Control-Max-Age': '86400',    'Vary': 'Origin',  };}// Add CORS headers to responsefunction addCorsHeaders(headers, request) {  const cors = corsHeaders(request);    for (const [key, value] of Object.entries(cors)) {    headers.set(key, value);  }}