// functions/api/proxy.jsexport async function onRequest(context) {  const { request } = context;  const url = new URL(request.url);  const targetUrl = url.searchParams.get('url');  if (request.method === 'OPTIONS') return handleOptions(request);  if (!targetUrl) return new Response('Missing URL', { status: 400 });  // 1. Identify File Type  const isPlaylist = targetUrl.includes('.m3u8');  const cache = caches.default;  const cacheKey = new Request(request.url, request);  // 2. Bypass Cache for Playlists Entirely  if (!isPlaylist) {    let cachedResponse = await cache.match(cacheKey);    if (cachedResponse) return cachedResponse;  }  try {    const proxyRequest = new Request(targetUrl, {      method: 'GET',      headers: filterHeaders(request.headers),      redirect: 'follow',    });    const response = await fetch(proxyRequest);        // Check if the final URL changed (due to redirects)    // This is often why streams restart/fail    const finalUrl = response.url || targetUrl;     const contentType = response.headers.get('content-type') || '';    if (isPlaylist || contentType.includes('mpegurl')) {      let text = await response.text();            // Calculate base URL from the ACTUAL final URL after redirects      const targetBaseUrl = new URL('.', finalUrl).href;      const proxyBaseUrl = `${url.origin}${url.pathname}?url=`;      const lines = text.split('\n').map(line => {        const trimmed = line.trim();        if (trimmed === '' || trimmed.startsWith('#')) {          // Fix for Absolute-Path tags like #EXT-X-MAP:URI="/path/to/init.mp4"          if (trimmed.startsWith('#EXT-X-MAP:URI="')) {            const innerUrl = trimmed.match(/"([^"]+)"/)[1];            const abs = new URL(innerUrl, targetBaseUrl).href;            return trimmed.replace(innerUrl, `${proxyBaseUrl}${encodeURIComponent(abs)}`);          }          return line;        }                // Resolve segment/sub-playlist URLs        const absoluteUrl = new URL(trimmed, targetBaseUrl).href;        return `${proxyBaseUrl}${encodeURIComponent(absoluteUrl)}`;      });      const newResponse = new Response(lines.join('\n'), {        headers: {          //'Content-Type': 'application/vnd.apple.mpegurl',          'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',          'Access-Control-Allow-Origin': '*',        }      });      return newResponse;    } else {      // Handle Segments      const segmentResponse = new Response(response.body, {        status: response.status,        headers: filterResponseHeaders(response.headers),      });      segmentResponse.headers.set('Cache-Control', 'public, max-age=3600');            // Only cache if it's a successful segment fetch      if (response.ok) {        context.waitUntil(cache.put(cacheKey, segmentResponse.clone()));      }      return segmentResponse;    }  } catch (error) {    return new Response(`Proxy Error: ${error.message}`, { status: 500 });  }}function filterHeaders(headers) {  const h = new Headers();  // Standardize UA to prevent 403 Forbidden errors from some providers  h.set('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');  if (headers.has('range')) h.set('range', headers.get('range'));  return h;}function filterResponseHeaders(headers) {  const h = new Headers();  const keep = ['content-type', 'content-length', 'accept-ranges', 'content-encoding'];  for (const [key, value] of headers.entries()) {    if (keep.includes(key.toLowerCase())) h.set(key, value);  }  return h;}function handleOptions(request) {  return new Response(null, {    status: 204,    headers: {      'Access-Control-Allow-Origin': '*',      'Access-Control-Allow-Methods': 'GET, OPTIONS',      'Access-Control-Allow-Headers': '*',      'Access-Control-Max-Age': '86400',    }  });}function addCorsHeaders(headers) {  headers.set('Access-Control-Allow-Origin', '*');  headers.set('Access-Control-Expose-Headers', '*');}