// functions/api/proxy.jsexport async function onRequest(context) {  const { request } = context;  const url = new URL(request.url);  const targetUrl = url.searchParams.get('url');  if (request.method === 'OPTIONS') return handleOptions(request);  if (!targetUrl) return new Response('Missing URL', { status: 400 });  const isPlaylist = targetUrl.includes('.m3u8');  const cache = caches.default;  const cacheKey = new Request(request.url, request);  // Don't cache playlists  if (!isPlaylist) {    let cachedResponse = await cache.match(cacheKey);    if (cachedResponse) return cachedResponse;  }  try {    // Add proper headers for streaming    const proxyRequest = new Request(targetUrl, {      method: 'GET',      headers: filterHeaders(request.headers, request),      redirect: 'follow',    });    const response = await fetch(proxyRequest);        // Get the final URL after redirects    const finalUrl = response.url || targetUrl;    const contentType = response.headers.get('content-type') || '';    // Handle M3U8 playlists    if (isPlaylist || contentType.includes('mpegurl') || contentType.includes('application/vnd.apple.mpegurl')) {      let text = await response.text();            // Get base URL from the final URL      const targetBaseUrl = new URL('.', finalUrl).href;      const proxyBaseUrl = `${url.origin}${url.pathname}?url=`;      // Process each line      const lines = text.split('\n').map(line => {        const trimmed = line.trim();                // Keep comment lines and tags        if (trimmed.startsWith('#')) {          // Handle URIs in tags like #EXT-X-KEY, #EXT-X-MAP, etc.          if (trimmed.includes('URI="')) {            return line.replace(/URI="([^"]+)"/g, (match, uri) => {              try {                const absoluteUri = new URL(uri, targetBaseUrl).href;                return `URI="${proxyBaseUrl}${encodeURIComponent(absoluteUri)}"`;              } catch {                return match;              }            });          }          return line;        }                // Skip empty lines        if (trimmed === '') return line;                // Convert relative/absolute URLs to proxied URLs        try {          const absoluteUrl = new URL(trimmed, targetBaseUrl).href;          return `${proxyBaseUrl}${encodeURIComponent(absoluteUrl)}`;        } catch {          // If URL parsing fails, return original line          return line;        }      });      const newResponse = new Response(lines.join('\n'), {        headers: {          'Content-Type': 'application/vnd.apple.mpegurl',          'Cache-Control': 'no-cache, no-store, must-revalidate',          'Pragma': 'no-cache',          'Expires': '0',          'Access-Control-Allow-Origin': '*',          'Access-Control-Allow-Methods': 'GET, OPTIONS',          'Access-Control-Allow-Headers': '*',        }      });            return newResponse;    } else {      // Handle segments (TS files, etc.)      const segmentResponse = new Response(response.body, {        status: response.status,        statusText: response.statusText,        headers: filterResponseHeaders(response.headers),      });      // Add CORS headers      segmentResponse.headers.set('Access-Control-Allow-Origin', '*');      segmentResponse.headers.set('Access-Control-Expose-Headers', '*');            // Cache segments for better performance      if (response.ok) {        segmentResponse.headers.set('Cache-Control', 'public, max-age=3600');        context.waitUntil(cache.put(cacheKey, segmentResponse.clone()));      } else {        segmentResponse.headers.set('Cache-Control', 'no-cache');      }            return segmentResponse;    }  } catch (error) {    return new Response(`Proxy Error: ${error.message}`, {       status: 500,      headers: {        'Access-Control-Allow-Origin': '*',        'Content-Type': 'text/plain'      }    });  }}function filterHeaders(headers, originalRequest) {  const h = new Headers();    // Essential headers for streaming  h.set('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');    // Forward range headers for seeking  if (headers.has('range')) {    h.set('range', headers.get('range'));  }    // Forward other important headers  const forwardHeaders = ['accept', 'accept-encoding', 'accept-language', 'connection'];  for (const header of forwardHeaders) {    if (headers.has(header)) {      h.set(header, headers.get(header));    }  }    // Handle cookies if present  if (headers.has('cookie')) {    h.set('cookie', headers.get('cookie'));  }    // Handle referer if present (some streams need this)  if (headers.has('referer')) {    h.set('referer', headers.get('referer'));  } else {    // Set referer to the target URL's origin for some providers    try {      const targetUrl = new URL(originalRequest.url);      h.set('referer', targetUrl.origin);    } catch {}  }    return h;}function filterResponseHeaders(headers) {  const h = new Headers();    // Keep essential headers for streaming  const keep = [    'content-type',     'content-length',     'content-range',    'accept-ranges',     'content-encoding',    'last-modified',    'etag'  ];    for (const [key, value] of headers.entries()) {    const lowerKey = key.toLowerCase();    if (keep.includes(lowerKey)) {      h.set(key, value);    }  }    return h;}function handleOptions(request) {  return new Response(null, {    status: 204,    headers: {      'Access-Control-Allow-Origin': '*',      'Access-Control-Allow-Methods': 'GET, OPTIONS, HEAD',      'Access-Control-Allow-Headers': '*',      'Access-Control-Max-Age': '86400',      'Access-Control-Expose-Headers': '*',    }  });}