// functions/api/proxy.jsexport async function onRequest(context) {  const { request } = context;  const url = new URL(request.url);  const targetUrl = url.searchParams.get('url');  if (request.method === 'OPTIONS') return handleOptions(request);  if (!targetUrl) return new Response('Missing URL', { status: 400 });  const cache = caches.default;  const cacheKey = new Request(request.url, request);    // 1. Check if Cloudflare already has this in the edge cache  let cachedResponse = await cache.match(cacheKey);  if (cachedResponse) {    // Add a header so you can see it's a cache hit in the browser console    const hitResponse = new Response(cachedResponse.body, cachedResponse);    hitResponse.headers.set('X-Proxy-Cache', 'HIT');    return hitResponse;  }  try {    const proxyRequest = new Request(targetUrl, {      method: 'GET',      headers: filterHeaders(request.headers),      redirect: 'follow',    });    const response = await fetch(proxyRequest);        // Copy the original response to modify headers    let newResponse;    const contentType = response.headers.get('content-type') || '';    // 2. Handle M3U8 Rewriting (Playlist)    if (targetUrl.includes('.m3u8') || contentType.includes('mpegurl')) {      let text = await response.text();      const targetBaseUrl = targetUrl.substring(0, targetUrl.lastIndexOf('/') + 1);      const proxyBaseUrl = `${url.origin}${url.pathname}?url=`;      const lines = text.split('\n').map(line => {        if (line.trim() === '' || line.startsWith('#')) return line;        const absoluteUrl = line.startsWith('http') ? line : new URL(line, targetBaseUrl).href;        return `${proxyBaseUrl}${encodeURIComponent(absoluteUrl)}`;      });      newResponse = new Response(lines.join('\n'), {        headers: {          //'Content-Type': 'application/vnd.apple.mpegurl',          // Playlists usually shouldn't be cached long, but following your 2min request:          //'Cache-Control': 'public, s-maxage=120', 		  'Content-Type': 'text/plain', // Use text/plain to avoid detection          'Cache-Control': 'public, max-age=2', // Short cache for playlist          'Access-Control-Allow-Origin': '*',		  'Access-Control-Allow-Methods': 'GET, HEAD, OPTIONS',          'Access-Control-Expose-Headers': 'Content-Length, Content-Range',        }      });    } else {      // 3. Handle Segments (.txt, .ts, etc.)      newResponse = new Response(response.body, {        status: response.status,        headers: filterResponseHeaders(response.headers),      });      // Set Edge Cache to 2 minutes (120 seconds)      newResponse.headers.set('Cache-Control', 'public, max-age=2');    }    addCorsHeaders(newResponse.headers, request);    newResponse.headers.set('X-Proxy-Cache', 'MISS');    // 4. Save to Cloudflare Edge Cache    // Note: Cloudflare only caches if s-maxage or max-age is present    context.waitUntil(cache.put(cacheKey, newResponse.clone()));    return newResponse;  } catch (error) {    return new Response(`Proxy Error: ${error.message}`, { status: 500 });  }}// --- Helper Functions ---function filterHeaders(headers) {  const h = new Headers();  h.set('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36');  if (headers.has('range')) h.set('range', headers.get('range'));  return h;}function filterResponseHeaders(headers) {  const h = new Headers();  const keep = ['content-type', 'content-length', 'accept-ranges', 'content-encoding'];  for (const [key, value] of headers.entries()) {    if (keep.includes(key.toLowerCase())) h.set(key, value);  }  return h;}function handleOptions(request) {  return new Response(null, {    status: 204,    headers: {      'Access-Control-Allow-Origin': '*',      'Access-Control-Allow-Methods': 'GET, OPTIONS',      'Access-Control-Allow-Headers': '*',    }  });}function addCorsHeaders(headers, request) {  headers.set('Access-Control-Allow-Origin', '*');  headers.set('Access-Control-Expose-Headers', '*');}