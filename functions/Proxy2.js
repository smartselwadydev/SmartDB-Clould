// functions/api/proxy.jsexport async function onRequest(context) {  const { request } = context;    // Handle CORS preflight requests  if (request.method === 'OPTIONS') {    return handleOptions(request);  }  try {    // Get the target URL and printSource flag from the query parameters    const url = new URL(request.url);    const targetUrl = url.searchParams.get('url');    const printSource = url.searchParams.get('printSource') === 'true';        if (!targetUrl) {      return new Response('Missing "url" parameter', { status: 400 });    }    // Validate the URL    try {      new URL(targetUrl);    } catch {      return new Response('Invalid URL provided', { status: 400 });    }    // Prepare the request to forward    const proxyRequest = new Request(targetUrl, {      method: request.method,      headers: filterHeaders(request.headers),      body: request.method !== 'GET' && request.method !== 'HEAD' ? request.body : undefined,    });    // Fetch the target URL    const response = await fetch(proxyRequest);    // Check if the response is an M3U8 file    const contentType = response.headers.get('content-type') || '';    const isM3U8 = contentType.includes('application/vnd.apple.mpegurl') ||                    contentType.includes('application/x-mpegURL') ||                   targetUrl.includes('.m3u8');    // If it's an M3U8 file, process it to rewrite segment URLs    if (isM3U8 && !printSource) {      const m3u8Content = await response.text();      const processedContent = processM3U8Content(m3u8Content, targetUrl, url.origin + url.pathname);            const proxyResponse = new Response(processedContent, {        status: response.status,        statusText: response.statusText,        headers: filterResponseHeaders(response.headers),      });            // Ensure correct content type for M3U8      proxyResponse.headers.set('Content-Type', 'application/vnd.apple.mpegurl');            // Add CORS headers      addCorsHeaders(proxyResponse.headers, request);            return proxyResponse;    }    // If printSource is true, return the HTML source code    if (printSource) {      const text = await response.text();            // Create a response with the HTML source code      const sourceResponse = new Response(text, {        status: 200,        headers: {          'Content-Type': 'text/plain;charset=UTF-8',        },      });            // Add CORS headers      addCorsHeaders(sourceResponse.headers, request);            return sourceResponse;    }    // Otherwise, proxy the response as normal    const proxyResponse = new Response(response.body, {      status: response.status,      statusText: response.statusText,      headers: filterResponseHeaders(response.headers),    });    // Add CORS headers    addCorsHeaders(proxyResponse.headers, request);    return proxyResponse;  } catch (error) {    return new Response(`Proxy error: ${error.message}`, {       status: 500,      headers: corsHeaders(request)    });  }}// Process M3U8 content to rewrite segment URLsfunction processM3U8Content(content, originalUrl, proxyBaseUrl) {  const lines = content.split('\n');  const processedLines = [];    // Parse the original URL to get the base path  const originalUrlObj = new URL(originalUrl);  const basePath = originalUrlObj.pathname.substring(0, originalUrlObj.pathname.lastIndexOf('/') + 1);  const baseUrl = `${originalUrlObj.protocol}//${originalUrlObj.host}${basePath}`;  for (let line of lines) {    // Skip comments and empty lines    if (line.startsWith('#') || line.trim() === '') {      processedLines.push(line);      continue;    }    // Check if it's a segment URL or another M3U8 (for variants)    const trimmedLine = line.trim();        // Check if it's already a full URL    if (trimmedLine.startsWith('http://') || trimmedLine.startsWith('https://')) {      // Rewrite full URL to go through proxy      const encodedUrl = encodeURIComponent(trimmedLine);      processedLines.push(`${proxyBaseUrl}?url=${encodedUrl}`);    } else {      // It's a relative path - construct full URL and proxy it      let fullUrl;      if (trimmedLine.startsWith('/')) {        // Absolute path within the same domain        fullUrl = `${originalUrlObj.protocol}//${originalUrlObj.host}${trimmedLine}`;      } else {        // Relative to the M3U8 file        fullUrl = `${baseUrl}${trimmedLine}`;      }            const encodedUrl = encodeURIComponent(fullUrl);      processedLines.push(`${proxyBaseUrl}?url=${encodedUrl}`);    }  }  return processedLines.join('\n');}// Handle OPTIONS preflight requestsfunction handleOptions(request) {  return new Response(null, {    status: 204,    headers: corsHeaders(request)  });}// Filter headers to forward (remove sensitive/unsafe headers)function filterHeaders(headers) {  const forbiddenHeaders = [    'cookie',    'origin',    'referer',    'accept-encoding',    'content-length',  ];  const filteredHeaders = new Headers();    for (const [key, value] of headers.entries()) {    if (!forbiddenHeaders.includes(key.toLowerCase())) {      filteredHeaders.set(key, value);    }  }  // Set a custom user agent  filteredHeaders.set('User-Agent', 'Cloudflare-CORS-Proxy/1.0');    return filteredHeaders;}// Filter response headersfunction filterResponseHeaders(headers) {  const forbiddenResponseHeaders = [    'set-cookie',    'content-security-policy',    'content-security-policy-report-only',  ];  const filteredHeaders = new Headers();    for (const [key, value] of headers.entries()) {    if (!forbiddenResponseHeaders.includes(key.toLowerCase())) {      filteredHeaders.set(key, value);    }  }    return filteredHeaders;}// Generate CORS headersfunction corsHeaders(request) {  const origin = request.headers.get('Origin') || '*';    return {    'Access-Control-Allow-Origin': origin,    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS',    'Access-Control-Allow-Headers': '*',    'Access-Control-Allow-Credentials': 'true',    'Access-Control-Max-Age': '86400',    'Vary': 'Origin',  };}// Add CORS headers to responsefunction addCorsHeaders(headers, request) {  const cors = corsHeaders(request);    for (const [key, value] of Object.entries(cors)) {    headers.set(key, value);  }}