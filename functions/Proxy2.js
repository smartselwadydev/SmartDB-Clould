export default {  async fetch(request, env) {    const url = new URL(request.url);    const baseUpstream = 'https://show1.beinconnect.us:5443/LiveApp/streams/live/';        const path = url.pathname;    const pathParts = path.split('/').filter(part => part);        // 1. CORS Preflight    if (request.method === 'OPTIONS') {      return new Response(null, {        headers: {          'Access-Control-Allow-Origin': '*',          'Access-Control-Allow-Methods': 'GET, HEAD, OPTIONS',          'Access-Control-Allow-Headers': '*',          'Access-Control-Max-Age': '86400'        }      });    }    // 2. Root Page    if (pathParts.length === 0 || path === '/') {      return new Response(`<h1>CDN Service Operational</h1><p>Service by: SMARTS ELWADY</p>`, {        headers: { 'Content-Type': 'text/html' }      });    }    // 3. FIX: Handle Playlist (.m3u8)    if (path.endsWith('.m3u') || path.endsWith('.m3u8')) {      const streamId = pathParts[pathParts.length - 1].replace('.m3u8', '').replace('.m3u', '');            try {        const upstreamResponse = await fetch(baseUpstream + streamId + '.m3u8', {          headers: {             'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',            'Accept': '*/*'          }        });        if (!upstreamResponse.ok) throw new Error(`Upstream error`);        let playlist = await upstreamResponse.text();                // Rewrite segments to point to our CDN path        playlist = playlist          .split('\n')          .map(line => {            const trimmedLine = line.trim();            if (trimmedLine && !trimmedLine.startsWith('#')) {              // This ensures segments are routed through our /cdn/ logic              return `/cdn/${streamId}/${trimmedLine}`;            }            return line;          })          .join('\n');        return new Response(playlist, {          headers: {            // FIX: Content-Type must be correct for many players to sync properly            'Content-Type': 'application/vnd.apple.mpegurl',            // FIX: CRITICAL - Disable all caching for the playlist to prevent restarting            'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',            'Pragma': 'no-cache',            'Expires': '0',            'Access-Control-Allow-Origin': '*',          }        });      } catch (error) {        return new Response('Error loading playlist', { status: 500 });      }    }    // 4. Handle CDN segment requests (.ts / .txt / .m4s)    if (path.startsWith('/cdn/')) {      const segmentPath = path.replace('/cdn/', '');      const segmentParts = segmentPath.split('/');            if (segmentParts.length >= 2) {        const streamId = segmentParts[0];        const segmentFile = segmentParts.slice(1).join('/');                // Pattern logic to find the file upstream        const possibleUpstreamUrls = [          `${baseUpstream}${streamId}/${segmentFile}`,          `${baseUpstream}${segmentFile}`        ];                for (const upstreamSegmentUrl of possibleUpstreamUrls) {          try {            const segmentResponse = await fetch(upstreamSegmentUrl, {              headers: {                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',                'Referer': baseUpstream              }            });                        if (segmentResponse.ok) {              const segmentData = await segmentResponse.arrayBuffer();                            let contentType = 'video/mp2t';               if (segmentFile.endsWith('.txt')) contentType = 'text/plain';              if (segmentFile.endsWith('.m4s')) contentType = 'video/iso.segment';              return new Response(segmentData, {                headers: {                  'Content-Type': contentType,                  // Segments ARE safe to cache                  'Cache-Control': 'public, max-age=3600',                  'Access-Control-Allow-Origin': '*',                  'Access-Control-Expose-Headers': 'Content-Length, Content-Range'                }              });            }          } catch (e) { continue; }        }      }    }    return new Response('Not Found', { status: 404 });  }};