// functions/api/proxy.jsexport async function onRequest(context) {  const { request } = context;    // Handle CORS preflight requests  if (request.method === 'OPTIONS') {    return handleOptions(request);  }  try {    // Get the target URL and printSource flag from the query parameters    const url = new URL(request.url);    const targetUrl = url.searchParams.get('url');    const printSource = url.searchParams.get('printSource') === 'true';        if (!targetUrl) {      return new Response('Missing "url" parameter', { status: 400 });    }    // Validate the URL    try {      new URL(targetUrl);    } catch {      return new Response('Invalid URL provided', { status: 400 });    }    // Parse the target URL to extract components    const targetUrlObj = new URL(targetUrl);        // Prepare custom headers based on the provided ones    // Removed pseudo-headers (:authority, :method, :path, :scheme) as they're automatically handled    const customHeaders = {      'accept': '*/*',      'accept-encoding': 'gzip, deflate, br, zstd',      'accept-language': 'en-US,en;q=0.9',      'origin': 'https://www.ksohls.ru',      'priority': 'u=1, i',      'referer': 'https://www.ksohls.ru/',      'sec-ch-ua': '"Not:A-Brand";v="99", "Google Chrome";v="145", "Chromium";v="145"',      'sec-ch-ua-mobile': '?1',      'sec-ch-ua-platform': '"iOS"',      'sec-fetch-dest': 'empty',      'sec-fetch-mode': 'cors',      'sec-fetch-site': 'cross-site',      'user-agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Mobile/15E148 Safari/604.1',      'host': targetUrlObj.hostname, // This replaces :authority    };    // Prepare the request to forward with custom headers    const proxyRequest = new Request(targetUrl, {      method: request.method,      headers: {        ...customHeaders,        // Add any additional headers from the original request that might be useful        ...filterHeaders(request.headers, true), // Pass true to keep more headers      },      body: request.method !== 'GET' && request.method !== 'HEAD' ? request.body : undefined,    });    // Fetch the target URL    const response = await fetch(proxyRequest);    // If printSource is true, return the HTML source code    if (printSource) {      const text = await response.text();            // Create a response with the HTML source code      const sourceResponse = new Response(text, {        status: 200,        headers: {          'Content-Type': 'text/plain;charset=UTF-8',        },      });            // Add CORS headers      addCorsHeaders(sourceResponse.headers, request);            return sourceResponse;    }    // Otherwise, proxy the response as normal    const proxyResponse = new Response(response.body, {      status: response.status,      statusText: response.statusText,      headers: filterResponseHeaders(response.headers),    });    // Add CORS headers    addCorsHeaders(proxyResponse.headers, request);    return proxyResponse;  } catch (error) {    return new Response(`Proxy error: ${error.message}`, {       status: 500,      headers: corsHeaders(request)    });  }}// Handle OPTIONS preflight requestsfunction handleOptions(request) {  return new Response(null, {    status: 204,    headers: corsHeaders(request)  });}// Filter headers to forward (remove sensitive/unsafe headers)// Added optional parameter to keep more headers when neededfunction filterHeaders(headers, keepAll = false) {  const forbiddenHeaders = keepAll ? [    'cookie',    'content-length',  ] : [    'cookie',    'origin',    'referer',    'user-agent',    'accept-encoding',    'content-length',  ];  const filteredHeaders = {};    for (const [key, value] of headers.entries()) {    if (!forbiddenHeaders.includes(key.toLowerCase())) {      filteredHeaders[key] = value;    }  }  return filteredHeaders;}// Filter response headersfunction filterResponseHeaders(headers) {  const forbiddenResponseHeaders = [    'set-cookie',    'content-security-policy',    'content-security-policy-report-only',  ];  const filteredHeaders = new Headers();    for (const [key, value] of headers.entries()) {    if (!forbiddenResponseHeaders.includes(key.toLowerCase())) {      filteredHeaders.set(key, value);    }  }    return filteredHeaders;}// Generate CORS headersfunction corsHeaders(request) {  const origin = request.headers.get('Origin') || '*';    return {    'Access-Control-Allow-Origin': origin,    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS',    'Access-Control-Allow-Headers': '*',    'Access-Control-Allow-Credentials': 'true',    'Access-Control-Max-Age': '86400',    'Vary': 'Origin',  };}// Add CORS headers to responsefunction addCorsHeaders(headers, request) {  const cors = corsHeaders(request);    for (const [key, value] of Object.entries(cors)) {    headers.set(key, value);  }}