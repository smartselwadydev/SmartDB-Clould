// functions/api/proxy.jsexport async function onRequest(context) {  const { request } = context;    if (request.method === 'OPTIONS') {    return handleOptions(request);  }  try {    const url = new URL(request.url);    const targetUrl = url.searchParams.get('url');        if (!targetUrl) {      return new Response('Missing "url" parameter', { status: 400 });    }    // 1. Create the request to the real server    const proxyRequest = new Request(targetUrl, {      method: request.method,      headers: filterHeaders(request.headers),      body: request.method !== 'GET' && request.method !== 'HEAD' ? request.body : undefined,    });    const response = await fetch(proxyRequest);    const contentType = response.headers.get('content-type') || '';    // 2. Logic for M3U8 Rewriting    if (targetUrl.includes('.m3u8') || contentType.includes('mpegurl') || contentType.includes('application/x-mpegURL')) {      let text = await response.text();      const targetBaseUrl = targetUrl.substring(0, targetUrl.lastIndexOf('/') + 1);      const proxyBaseUrl = `${url.origin}${url.pathname}?url=`;      // Rewrite lines that don't start with '#' (the actual file paths)      const lines = text.split('\n').map(line => {        if (line.trim() === '' || line.startsWith('#')) {          return line;        }                // Convert relative URL to absolute        const absoluteUrl = line.startsWith('http') ? line : new URL(line, targetBaseUrl).href;        // Wrap the absolute URL back into our proxy        return `${proxyBaseUrl}${encodeURIComponent(absoluteUrl)}`;      });      text = lines.join('\n');      const m3u8Response = new Response(text, {        status: 200,        headers: filterResponseHeaders(response.headers),      });            m3u8Response.headers.set('Content-Type', 'application/vnd.apple.mpegurl');      addCorsHeaders(m3u8Response.headers, request);      return m3u8Response;    }    // 3. Normal proxy for binary files (the .txt/ts segments)    const proxyResponse = new Response(response.body, {      status: response.status,      statusText: response.statusText,      headers: filterResponseHeaders(response.headers),    });    addCorsHeaders(proxyResponse.headers, request);    return proxyResponse;  } catch (error) {    return new Response(`Proxy error: ${error.message}`, {       status: 500,      headers: corsHeaders(request)    });  }}// --- Helper Functions (Keep your existing ones with these small tweaks) ---function handleOptions(request) {  return new Response(null, {    status: 204,    headers: corsHeaders(request)  });}function filterHeaders(headers) {  const filteredHeaders = new Headers();  const allowedHeaders = ['accept', 'range', 'accept-language']; // Minimalist approach    for (const [key, value] of headers.entries()) {    if (allowedHeaders.includes(key.toLowerCase())) {      filteredHeaders.set(key, value);    }  }  filteredHeaders.set('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36');  return filteredHeaders;}function filterResponseHeaders(headers) {  const filteredHeaders = new Headers();  // Ensure we keep content-type and timing headers  const important = ['content-type', 'content-length', 'cache-control'];    for (const [key, value] of headers.entries()) {    if (important.includes(key.toLowerCase())) {      filteredHeaders.set(key, value);    }  }  return filteredHeaders;}function corsHeaders(request) {  return {    'Access-Control-Allow-Origin': '*',    'Access-Control-Allow-Methods': 'GET, HEAD, OPTIONS',    'Access-Control-Allow-Headers': '*',    'Access-Control-Max-Age': '86400',  };}function addCorsHeaders(headers, request) {  const cors = corsHeaders(request);  for (const [key, value] of Object.entries(cors)) {    headers.set(key, value);  }}