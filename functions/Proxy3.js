// functions/api/proxy.jsexport async function onRequest(context) {  const { request, env } = context;    // Handle CORS preflight requests  if (request.method === 'OPTIONS') {    return handleOptions(request);  }  try {    // Get the target URL and printSource flag from the query parameters    const url = new URL(request.url);    const targetUrl = url.searchParams.get('url');    const printSource = url.searchParams.get('printSource') === 'true';    const bypassCache = url.searchParams.get('bypassCache') === 'true';        if (!targetUrl) {      return new Response('Missing "url" parameter', { status: 400 });    }    // Validate the URL    try {      new URL(targetUrl);    } catch {      return new Response('Invalid URL provided', { status: 400 });    }    // Check if we have a cached response (only for GET requests)    if (request.method === 'GET' && !bypassCache) {      const cacheKey = new Request(url.toString(), request);      const cache = caches.default;      let cachedResponse = await cache.match(cacheKey);            if (cachedResponse) {        // Add CORS headers to cached response        const newHeaders = new Headers(cachedResponse.headers);        addCorsHeaders(newHeaders, request);                return new Response(cachedResponse.body, {          status: cachedResponse.status,          statusText: cachedResponse.statusText,          headers: newHeaders,        });      }    }    // Prepare the request to forward    const proxyRequest = new Request(targetUrl, {      method: request.method,      headers: filterHeaders(request.headers),      body: request.method !== 'GET' && request.method !== 'HEAD' ? request.body : undefined,    });    // Add cache control headers to the outgoing request    proxyRequest.headers.set('Cache-Control', 'max-age=3600'); // Request cache for 1 hour    // Fetch the target URL    const response = await fetch(proxyRequest);    // Check if the response is an M3U8 file    const contentType = response.headers.get('content-type') || '';    const isM3U8 = contentType.includes('application/vnd.apple.mpegurl') ||                    contentType.includes('application/x-mpegURL') ||                   targetUrl.includes('.m3u8') ||                   targetUrl.includes('.m3u');    // Determine cache TTL based on content type    let cacheTTL = 3600; // Default 1 hour        if (isM3U8) {      cacheTTL = 60; // Cache M3U8 playlists for 1 minute (they change frequently)    } else if (targetUrl.includes('.ts') || targetUrl.includes('.txt')) {      cacheTTL = 86400; // Cache segments for 24 hours (they don't change)    }    // Process M3U8 content if needed    let finalResponse;        if (isM3U8 && !printSource) {      const m3u8Content = await response.text();      const processedContent = processM3U8Content(m3u8Content, targetUrl, url.origin + url.pathname);            finalResponse = new Response(processedContent, {        status: response.status,        statusText: response.statusText,        headers: filterResponseHeaders(response.headers),      });            // Ensure correct content type for M3U8      finalResponse.headers.set('Content-Type', 'application/vnd.apple.mpegurl');          } else if (printSource) {      const text = await response.text();            finalResponse = new Response(text, {        status: 200,        headers: {          'Content-Type': 'text/plain;charset=UTF-8',        },      });          } else {      // Pass through the response body for non-M3U8 content      finalResponse = new Response(response.body, {        status: response.status,        statusText: response.statusText,        headers: filterResponseHeaders(response.headers),      });    }    // Add cache control headers    finalResponse.headers.set('Cache-Control', `public, max-age=${cacheTTL}`);    finalResponse.headers.set('CDN-Cache-Control', `public, max-age=${cacheTTL}`);    finalResponse.headers.set('Cloudflare-CDN-Cache-Control', `public, max-age=${cacheTTL}`);        // Add ETag for better cache validation    const etag = `"${generateETag(finalResponse)}"`;    finalResponse.headers.set('ETag', etag);    // Add CORS headers    addCorsHeaders(finalResponse.headers, request);    // Cache the response if it's a GET request and not printSource    if (request.method === 'GET' && !printSource && !bypassCache) {      const cacheKey = new Request(url.toString(), request);      const cache = caches.default;            // Clone the response before caching      await cache.put(cacheKey, finalResponse.clone());    }    return finalResponse;  } catch (error) {    return new Response(`Proxy error: ${error.message}`, {       status: 500,      headers: corsHeaders(request)    });  }}// Process M3U8 content to rewrite segment URLsfunction processM3U8Content(content, originalUrl, proxyBaseUrl) {  const lines = content.split('\n');  const processedLines = [];    // Parse the original URL to get the base path  const originalUrlObj = new URL(originalUrl);  const basePath = originalUrlObj.pathname.substring(0, originalUrlObj.pathname.lastIndexOf('/') + 1);  const baseUrl = `${originalUrlObj.protocol}//${originalUrlObj.host}${basePath}`;  // Add cache hint comment  processedLines.push('# Cloudflare-Cached-Proxy: enabled');  for (let line of lines) {    // Skip comments and empty lines    if (line.startsWith('#') || line.trim() === '') {      processedLines.push(line);      continue;    }    // Check if it's a segment URL or another M3U8 (for variants)    const trimmedLine = line.trim();        // Check if it's already a full URL    if (trimmedLine.startsWith('http://') || trimmedLine.startsWith('https://')) {      // Rewrite full URL to go through proxy with cache hint      const encodedUrl = encodeURIComponent(trimmedLine);      processedLines.push(`${proxyBaseUrl}?url=${encodedUrl}&cache=1`);    } else {      // It's a relative path - construct full URL and proxy it      let fullUrl;      if (trimmedLine.startsWith('/')) {        // Absolute path within the same domain        fullUrl = `${originalUrlObj.protocol}//${originalUrlObj.host}${trimmedLine}`;      } else {        // Relative to the M3U8 file        fullUrl = `${baseUrl}${trimmedLine}`;      }            const encodedUrl = encodeURIComponent(fullUrl);      processedLines.push(`${proxyBaseUrl}?url=${encodedUrl}&cache=1`);    }  }  return processedLines.join('\n');}// Generate a simple ETagfunction generateETag(response) {  // You could implement a more sophisticated ETag generation  // For now, we'll use a timestamp-based approach  return Math.random().toString(36).substring(2, 15);}// Handle OPTIONS preflight requestsfunction handleOptions(request) {  return new Response(null, {    status: 204,    headers: corsHeaders(request)  });}// Filter headers to forward (remove sensitive/unsafe headers)function filterHeaders(headers) {  const forbiddenHeaders = [    'cookie',    'origin',    'referer',    'accept-encoding',    'content-length',  ];  const filteredHeaders = new Headers();    for (const [key, value] of headers.entries()) {    if (!forbiddenHeaders.includes(key.toLowerCase())) {      filteredHeaders.set(key, value);    }  }  // Set a custom user agent  filteredHeaders.set('User-Agent', 'Cloudflare-CORS-Proxy/1.0');    return filteredHeaders;}// Filter response headersfunction filterResponseHeaders(headers) {  const forbiddenResponseHeaders = [    'set-cookie',    'content-security-policy',    'content-security-policy-report-only',  ];  const filteredHeaders = new Headers();    for (const [key, value] of headers.entries()) {    if (!forbiddenResponseHeaders.includes(key.toLowerCase())) {      filteredHeaders.set(key, value);    }  }    return filteredHeaders;}// Generate CORS headersfunction corsHeaders(request) {  const origin = request.headers.get('Origin') || '*';    return {    'Access-Control-Allow-Origin': origin,    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS',    'Access-Control-Allow-Headers': '*',    'Access-Control-Allow-Credentials': 'true',    'Access-Control-Max-Age': '86400',    'Vary': 'Origin',  };}// Add CORS headers to responsefunction addCorsHeaders(headers, request) {  const cors = corsHeaders(request);    for (const [key, value] of Object.entries(cors)) {    headers.set(key, value);  }}